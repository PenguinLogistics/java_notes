一、程序、进程、线程
程序：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。
进程：是程序的一次执行过程，或是正在执行的程序。是一个动态的过程，有它自身的产生、存在和消亡过程（生命周期）
    >进程作为资源分配单位，系统在运行时会为每个进程分配不同的内存区域
线程：进程可以进一步细化为线程，是一个程序内部的一条执行路径。
    >若一个进程同一时间并行执行多个线程，就是支持多线程的
    >线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（JVM），线程切换的开销小
    >一个进程中的多个线程共享相同的内存单元/内存地址空间（JVM中共享方法区和堆）->它们从同一堆中分配对象，可以方位相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患

并行和并发
    >并行：多个cpu同时执行多个任务
    >并发：一个cpu（采用时间片）同时执行多个任务

多线程的优点
    背景：以单核cpu为例，只使用单个线程先后完成多个任务，肯定比用多线程来完成用的时间更短。（因为切换上下文需要时间）
    1.提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
    2.提高计算机系统cpu的利用率
    3.改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改

何时需要使用多线程
    程序需要同时执行两个或多个任务
    程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索
    需要一些后台运行的程序时

二、单核和多核cpu
单核cpu是一种假的多线程，因为在一个时间单元内，也只能执行一个线程任务。但因为cpu时间单元特别短，因此感觉不出来
多核cpu才能更好的发挥多线程的效率（现在的服务器都是多核的）
一个java应用程序java.exe 其中至少有三个线程：main()主线程 gc()垃圾回收线程 异常处理线程（如果发生异常，会影响主线程）


三、多线程的创建
方式一：继承Thread类
demo01

* 多线程的创建 方式一：继承Thread类
* 1.创建一个继承于Thread类的子类
* 2.重写Thread类的run()方法 --> 将此线程执行的操作生命在run()中
* 3.创建Thread类的子类对象
* 4.通过此对象调用start()

Thread类中常用的方法
1.start(): 启动当前线程，调用当前线程的run()
2.run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中
3.currentThread(): 静态方法，返回当前代码执行的线程
4.getName(): 获取当前线程的名字
5.setName(): 设置当前线程的名字
6.yield(): 释放当前cpu的执行权
7.join(): 在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b执行完以后，线程a才结束阻塞状态（c语言中为了等待回收子线程？？）
//8.stop(): 已经过时
9.sleep(long millitime): 让当前线程 睡眠 指定的millitime毫秒。在指定millitime毫秒时间内，当前线程是阻塞状态。
10.isAlive(线程名): 判断当前线程是否存活

主线程中不能直接调用（因为没有继承Thread类？），Thread.静态方法()、Thread.currentThread().方法() 都可以在主线程中调用Thread的方法

线程的优先级
MAX_PRIORITY 10
MIN_PRIORITY 1
NORM_PRIORITY 5
方法
getPriority() 返回线程优先级
setPriority(new priority) 设置线程优先级
说明：高优先级的线程要抢占低优先级线程的cpu执行权，但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有高优先级线程执行完以后，低优先级线程才执行


方式二：实现Runnable接口
demo02

* 1. 创建一个实现了runnable接口的类
* 2. 实现类中实现Runnable中的抽象方法 run()
* 3. 创建实现类的对象
* 4. 将此对象作为参数传递到Thread类构造器中，创建Thread类的对象
* 5. 通过Thread类的对象调用 start()
        start方法 ①启动当前线程 ②调用了当前线程的run() 当前线程的run()调用了形参 Runnable target 的run()方法

比较创建线程两种方式
开发中 优先选择实现runnable接口 原因：
    1. 没有类的单继承性的局限性
    2. 更适合来处理多个线程共享数据的情况
相同点：都重写了 run() 方法，将线程要执行的逻辑声明在run() 中

四、线程的生命周期
jdk中用Thread.State 内部类定义了线程的几种状态

新建
|
|调用start()
|
就绪←---------------------
↑|                       |
|| 获取cpu执行权         阻塞 sleep(long time) || join() ||等待同步锁 || wait() || suspend()
|| 失去cpu执行权          ↑
|↓                       |
运行----------------------
|
|  执行完run() || 调用现成的stop || 出现Error/Exception且没处理
|
死亡


五、线程安全
例子：创建三个卖票窗口，总票数为100张，使用runnable接口方式
1. 问题：卖票过程中，出现了重票、错票 --> 出现了线程安全问题
2. 原因：当某个线程操作ticket过程中，尚未操作完成时，其他线程参与进来，也操作ticket
3. 如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。知道线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变
4. 在java中，我们通过线程同步机制，来解决线程安全问题

方式一：同步代码块
    synchronized(同步监视器) {
        //需要被同步的代码
    }
    说明：
    1. 操作共享数据的代码，即为需要被同步的代码 --> 不能包含代码多了，也不能包含代码少了
    2. 共享数据：多个线程共同操作的变量。比如：ticket就是共享数据
    3. 同步监视器，俗称：锁。任何一个类的对象，都可以充当锁
        要求：多个线程必须要共用同一把锁

    补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器
    可以用 .class 充当同步监视器

方式二：同步方法
    如果操作共享数据的代码完整的声明在一个方法中，我们将此方法声明同步的

    1. 同步方法仍然涉及到同步监视器，只是不需要我们声明
    2. 非静态的同步方法，同步监视器是 this
       静态同步方法，同步监视器是 当前类本身

方式三：Lock锁 （JDK5.0新增
    LockTest

    1. 创建一个Lock对象
    2. 调用lock()
    3. 调用unlock()

synchronized & Lock 的异同
    相同：二者都可以解决线程安全问题
    不同：synchronized 机制在执行完相应的同步代码以后，自动释放同步监视器
         Lock需要手动的启动同步，结束同步也需要手动实现

5. 优缺点
同步的方式，解决了线程安全问题（好处）
操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低

6. 线程安全的单例（懒汉）模式
    Bank

7. 死锁：不同线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
    TrheadTest

    出现死锁后，不会出现异常，不会出现提示，只是所有线程都处于阻塞状态无法继续
    我们使用同步时，要避免出现死锁

    解决方法
        专门的算法、原则
        尽量减少同步资源的定义
        尽量避免嵌套同步


六、线程通信
    Communication
wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器
notify()：一旦执行此方法，就会唤醒被 wait() 的一个线程。如果有个多个线程被wait，就唤醒优先级最高的
notifyAll()：一旦执行此方法，就会唤醒所有被 wait() 的一个线程。

说明
1. wait() notify() notifyAll() 只能出现在 同步代码块/方法 内部
2. wait() notify() notifyAll() 的调用者必须是同步代码块/方法中的同步监视器
    否则会出现 IllegalMonitorStateException
3. wait() notify() notifyAll() 定义在java.lang.Object中



















